## 在排序数组中查找一个target：二分查找

二分查找算法的基本思想是：

  将待查找区间的中间位置与目标值进行比较，进而缩小查找范围，直到找到目标值或确定不存在目标值为止。

二分查找的具体过程：

1. 定义两个指针 left 和 right 分别指向数组的第一个元素和最后一个元素，定义一个变量 mid 表示中间位置。
2. 如果目标值等于中间位置的值，则返回中间位置的下标。
3. 如果目标值小于中间位置的值，则将 right 指针移动到 mid-1 的位置，即在左侧继续查找。
4. 如果目标值大于中间位置的值，则将 left 指针移动到 mid+1 的位置，即在右侧继续查找。
5. 重复上述步骤，直到找到目标值或者 left > right。

计算中间位置以便进行二分查找：

int mid = ((right - left) >> 1) + left;

```cpp

classSolution {
    public intsearchInsert(int[] nums, int target) {
      int left =0, right = nums.length -1; // 注意
      while(left <= right) { // 注意
          int mid = (left + right) /2; // 注意
          if(nums[mid] == target) { // 注意
                          // 相关逻辑
            } elseif(nums[mid] < target) {
                        // 相关逻辑
              left = mid +1; // 注意
              } else {
                right = mid -1; // 注意
                }
      }
              // 相关返回值
      return 0;
    }
}
```

## DP

写状态转移方程

注意一开始几种情况，要特别返回

## 递归

递去归来


递归需要满足的三个条件：

1.一个问题的解可以分解为若干个子问题的解

2.这个问题与分解的子问题，除了书数据规模不同外，求解思路相同

3.存在递归中止条件

递归的关键：

写出递归公式，找到终止条件

递归是指一个函数自调用自身的过程，可以解决很多复杂问题，如汉诺塔、斐波那契数列等。递归函数需要基准情形，即递归结束的条件，否则会出现无限递归导致程序崩溃。由于递归调用会增加函数调用栈的深度，因此在实现递归函数时需要注意栈空间的使用情况。

## 迭代

迭代是指通过循环的方式来解决问题，与递归相比，迭代更加高效，因为迭代不需要函数调用栈和参数的传递，能够降低系统开销。迭代适用于可以描述为重复某个操作的问题，如求解动态规划、搜索算法等。

引入一个队列，这是把递归程序改写成迭代程序的常用方法。

## 模拟

模拟是指根据实际情况模拟出一种算法，通过对算法的模拟来解决实际问题。通常在模拟过程中需要考虑时间复杂度和空间复杂度。模拟可以用于生成测试数据和检验算法的正确性，例如可以模拟快速排序和归并排序来比较它们的效率和正确性。

## 排序

### 归并排序

归并排序是一种分治思想的排序算法，将一个数组分成两个部分，递归地对两个部分进行排序，然后合并两个已排好序的部分。归并排序的步骤如下：

1. 将待排数组从中间分成两个部分；
2. 对左半部分和右半部分分别递归调用归并排序；
3. 将已排好序的左半部分和右半部分进行合并，形成一个新的有序数组。

具体的合并过程可以采用指针或额外的数组来实现，其中额外的数组可以减少归并排序过程中的访存次数，提高效率。

归并排序的时间复杂度为O(nlogn)，空间复杂度为O(n)。
它的稳定性得益于归并时相等元素的相对位置不变。相比于快速排序，归并排序更适用于数据量较大的情况，而且它不需要额外的内存空间来存储中间结果。


## 树

中序遍历：

递归公式: preorder(node) = preorder(node->left) --> print node —> preorder(node->right)

中止条件：node 是否为空，为空则返回
