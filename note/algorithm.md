## 在排序数组中查找一个target：二分查找

二分查找算法的基本思想是：

  将待查找区间的中间位置与目标值进行比较，进而缩小查找范围，直到找到目标值或确定不存在目标值为止。

二分查找的具体过程：

1. 定义两个指针 left 和 right 分别指向数组的第一个元素和最后一个元素，定义一个变量 mid 表示中间位置。
2. 如果目标值等于中间位置的值，则返回中间位置的下标。
3. 如果目标值小于中间位置的值，则将 right 指针移动到 mid-1 的位置，即在左侧继续查找。
4. 如果目标值大于中间位置的值，则将 left 指针移动到 mid+1 的位置，即在右侧继续查找。
5. 重复上述步骤，直到找到目标值或者 left > right。

计算中间位置以便进行二分查找：

int mid = ((right - left) >> 1) + left;

```cpp

classSolution {
    public intsearchInsert(int[] nums, int target) {
      int left =0, right = nums.length -1; // 注意
      while(left <= right) { // 注意
          int mid = (left + right) /2; // 注意
          if(nums[mid] == target) { // 注意
                          // 相关逻辑
            } elseif(nums[mid] < target) {
                        // 相关逻辑
              left = mid +1; // 注意
              } else {
                right = mid -1; // 注意
                }
      }
              // 相关返回值
      return 0;
    }
}
```

## DP

写状态转移方程

注意一开始几种情况，要特别返回

## 递归

递去归来


递归需要满足的三个条件：

1.一个问题的解可以分解为若干个子问题的解

2.这个问题与分解的子问题，除了书数据规模不同外，求解思路相同

3.存在递归中止条件

递归的关键：

写出递归公式，找到终止条件

递归是指一个函数自调用自身的过程，可以解决很多复杂问题，如汉诺塔、斐波那契数列等。递归函数需要基准情形，即递归结束的条件，否则会出现无限递归导致程序崩溃。由于递归调用会增加函数调用栈的深度，因此在实现递归函数时需要注意栈空间的使用情况。

## 迭代

迭代是指通过循环的方式来解决问题，与递归相比，迭代更加高效，因为迭代不需要函数调用栈和参数的传递，能够降低系统开销。迭代适用于可以描述为重复某个操作的问题，如求解动态规划、搜索算法等。

引入一个队列，这是把递归程序改写成迭代程序的常用方法。


## 迭代和模拟的相互转换

递归本质上是通过函数自身不断调用来解决问题的，通常使用递归实现代码较为简洁，但是会带来较大的空间复杂度（在大量递归调用时可能导致函数调用栈溢出）和潜在的时间效率问题。
为了避免这种情况，可以采用迭代的方法来模拟递归计算过程，从而优化代码的性能。
具体的转换方法如下：

1. 函数调用栈 --> 显式栈

将函数调用栈中的各种信息记录到一个栈数据结构中，这样就可以通过循环控制来模拟递归过程，而不需要使用函数调用栈中的空间。
2. 函数参数 --> 局部变量

将函数参数改为局部变量，通过循环来动态更新这些变量的值，从而实现递归过程。
3. 递归终止条件 --> 循环退出条件

递归过程通常需要考虑终止条件，否则会导致死循环。在迭代中，可以通过一个循环判断条件来代替递归中的终止条件，从而实现迭代过程。

例如，考虑下面一个简单的递归函数：

```cpp
int factorial(int n) {
  if (n == 0) {
    return 1;
  } else {
    return n * factorial(n-1);
  }
}
```

将其转换为迭代的方式，可以得到以下实现：

```cpp
int factorial(int n) {
  stack<int> stk; // 显式栈
  stk.push(n);
  int res = 1;
  while (!stk.empty()) { // 循环退出条件
    int x = stk.top();
    stk.pop();
    if (x > 0) { // 递归终止条件
    res *= x;
    stk.push(x-1);
    }
  }
  return res;
}
```

在这个实现中，我们使用了一个显式栈来代替递归调用栈，并且将函数参数 `n` 改为了局部变量 `x`，使用循环来动态更新 `x` 的值来模拟递归过程，最后使用一个循环退出条件 `!stk.empty()` 来代替递归终止条件 `x==0`。

## 模拟

模拟是指根据实际情况模拟出一种算法，通过对算法的模拟来解决实际问题。通常在模拟过程中需要考虑时间复杂度和空间复杂度。模拟可以用于生成测试数据和检验算法的正确性，例如可以模拟快速排序和归并排序来比较它们的效率和正确性。


## DFS

### DFS和递归的区别
DFS是一种算法，全称为Depth-First Search,深度优先搜索。递归是一种编程技巧，指的是函数自己调用自己的过程。DFS中可以使用递归来实现，但是DFS不一定需要使用递归来实现，而递归也不一定是用来实现DFS的。

以下是DFS和递归的区别：

DFS是一种搜索策略，通常用于图的遍历、最短路径问题、拓扑排序等，而递归则是一种算法实现的方式，可以用于各种问题的解决，不一定是搜索问题。

DFS通常需要使用栈（显式或者隐式），把遍历的点压入栈中，弹出栈顶来继续遍历。而递归则是通过函数调用栈来实现自调用，每个子问题都是一个函数调用。

DFS是一种通用算法，其实现方式不限于递归。在实际应用中，可以使用递归、非递归（借助栈）等方式来实现。相反，递归只是编程中一种常用实现方式之一。

DFS的时间复杂度是与搜索树的深度有关的，最坏情况下可能退化成线性的时间复杂度。而递归的时间复杂度则与递归层数有关，最坏情况下可能会由于过多的递归层数导致函数调用栈溢出。

## 排序

### 归并排序

归并排序是一种分治思想的排序算法，将一个数组分成两个部分，递归地对两个部分进行排序，然后合并两个已排好序的部分。归并排序的步骤如下：

1. 将待排数组从中间分成两个部分；
2. 对左半部分和右半部分分别递归调用归并排序；
3. 将已排好序的左半部分和右半部分进行合并，形成一个新的有序数组。

具体的合并过程可以采用指针或额外的数组来实现，其中额外的数组可以减少归并排序过程中的访存次数，提高效率。

归并排序的时间复杂度为O(nlogn)，空间复杂度为O(n)。
它的稳定性得益于归并时相等元素的相对位置不变。相比于快速排序，归并排序更适用于数据量较大的情况，而且它不需要额外的内存空间来存储中间结果。


## 树

中序遍历：

递归公式: preorder(node) = preorder(node->left) --> print node —> preorder(node->right)

中止条件：node 是否为空，为空则返回
