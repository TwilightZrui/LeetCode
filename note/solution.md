## 13.罗马数字转整数

分析数学关系
基础：查表，unordered map
![1682395113930](image/solution/1682395113930.png)

## 14.最长公共前缀

横向扫描，如果字符串匹配，继续和下一个匹配
开始索引
函数重载
注意判断字符串是否为空
基础：字符串截取
![1682397043942](image/solution/1682397043942.png)

## 20有效的括号

栈：为什么要用栈，因为可能存在括号嵌套
哈希表：为什么要用哈希表，因为要插括号匹配
逻辑找匹配：
如果先遇到右括号，那一定是不对的，返回false；如果已经遍历了一会，再遇到右括号，则把栈顶弹出
如果先遇到左括号，那应该压入栈，等着找右括号

最后判断的条件是，stack中还有没有元素，如果有的话，肯定是还剩下有没匹配的
基础：stack：
定义，弹出，只能访问栈顶元素

## 21.合并两个有序链表

递归
首先预处理，考虑极端情况
分解子问题，递归处理

## 26.删除有序数组中的重复项

双指针
快慢指针，快指针用来移动，慢指针用来写入

# 35.搜索插入位置

条件化简为：在一个有序数组中找第一个大于等于 target 的下标

## 58.最后一个单词的长度

反向遍历
从数组末尾开始遍历，先用while(--)把空格去掉
然后再用while(--)把字符拿出来
注意边界情况，index应该是大于等于0

## 66.加一

反向遍历
分析数学关系

## 70 爬楼梯

状态转移方程：
d[n] = dp[n-1]+dp[n-2]

C++开辟新数组：
int *dp = new int[n + 1];
dp[0] = 0;

基本方法：
![1682477119038](image/solution/1682477119038.png)
![1682477252864](image/solution/1682477252864.png)
开辟了n+1的地方，空间复杂度高

改进：
滚动数组：
![1682477690537](image/solution/1682477690537.png)
![1682477673775](image/solution/1682477673775.png)

## 83.删除排序链表中的重复元素

因为链表中自带指针，所以不需要双指针
一次遍历
首先判断整个链表是不是空的
防止越界，判断到current->next就可

## 206 反转链表

* 将 next 指针指向当前节点的下一个节点，避免链表的断裂；
* 将当前节点的 next 指针指向 prev，实现节点的反转；
* 将 prev 指针指向当前节点，为下一轮循环做好准备；
* 将 cur 指针指向 next，继续遍历。
  遍历完毕后，prev 指向新的头节点，即反转前原来的尾节点。

## 94.二叉树的中序遍历

递归：
中序遍历：
递归公式 Preorder(node) = Preorder(node->left)->print node->preorder(node->right)
中止条件：node是否为空，为空则返

迭代
用stack把递归的过程模拟出来

## 100.相同的树

深度优先搜索

## 101.对称二叉树

递归：和100一样，只不过是判断的是right=?left
迭代：用队列模拟

## 104.二叉树的最大深度

DFS:
要找最大深度，就是找max（left,right）+1
递归求解
中止条件：当前节点为空

BFS:
把每一层的节点都放入queue，遍历完这一层，depth+1

## 108.将有序数组转换为二叉搜索树

二叉搜索树，BST
BST的中序遍历是升序的，所以问题转化为根据BST的中序遍历恢复一颗高度平衡BST
思路：
以升序数组中的任意一个元素作为根节点，以该元素左边的升序序列构建左子树，以该元素右边的升序序列构建右子树，这样可以得到一颗BST
因为需要高度平衡，所以需要选择中间的元素作为根节点
构建过程只和index有关，和数据无关，因为升序数组解决了这个事情
递归：
1.空指针直接返回
2.寻找中间值mid，创建新节点
3.新节点左孩子指向遍历，遍历[left,mid-1]
3.新节点右孩子指向遍历，遍历[mid+1,left]

迭代:
1.创建三个队列，保存节点，左下标和右下标
2.节点队列弹出元素，左右下标队列弹出元素，当前节点赋值中间值，检查左右下标是否还能创建树节点

## 876.链表的中间结点

1.把链表变成数组，空间比较大
2.单指针，先用单指针算下链表有多少个节点，然后算下中间的点，返回中间链表节点。注意保护头指针
![1683968290634](image/solution/1683968290634.png)
3.双指针，快指针走两步，慢指针走一步，当快指针到末尾的时候，慢指针肯定在中间
Your runtime beats 100 % of cpp submissions
Your memory usage beats 63.61 % of cpp submissions (6.8 MB)

迭代：

## 109.有序链表转换二叉搜索树

有序数组变成了链表，可以一种笨办法先把链表变成有序数组
Your runtime beats 11.99 % of cpp submissions
Your memory usage beats 11.86 % of cpp submissions (28 MB)

用快慢指针找到链表的中位数，以该中无数为根节点，将中位数左右两边分成两个有序子链表
